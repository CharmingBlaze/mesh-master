import { EditableMesh } from '../mesh/EditableMesh';
import { Vector3, ID, Vector2 } from '../mesh/types'; // Assuming Vector3 is used for positions

/**
 * Parses an OBJ file content string and returns an EditableMesh.
 * 
 * @param objFileContent The string content of the OBJ file.
 * @returns An EditableMesh instance populated from the OBJ data.
 */
export function parseOBJ(objFileContent: string): EditableMesh {
  const mesh = new EditableMesh();
  const lines = objFileContent.split('\n');

  const objVertices: Vector3[] = []; // Stores raw vertex positions from 'v' lines
  const objUVs: Vector2[] = [];      // Stores raw UVs from 'vt' lines
  const objNormals: Vector3[] = [];  // Stores raw normals from 'vn' lines

  // Maps 1-based OBJ vertex index to our EditableMesh vertex ID
  const objVertexIndexToMeshId: ID[] = []; 

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith('#') || trimmedLine.length === 0) {
      continue; // Skip comments and empty lines
    }

    const parts = trimmedLine.split(/\s+/);
    const type = parts[0];

    switch (type) {
      case 'v': // Geometric vertex
        const x = parseFloat(parts[1]);
        const y = parseFloat(parts[2]);
        const z = parseFloat(parts[3]);
        // Store raw OBJ vertex temporarily, we'll add to EditableMesh and map ID later
        objVertices.push({ x, y, z });
        // Add to EditableMesh and store its ID
        const meshVertexId = mesh.addVertex({ x, y, z });
        objVertexIndexToMeshId.push(meshVertexId);
        break;

      case 'vt': // Texture coordinate
        const u = parseFloat(parts[1]) || 0;
        const v = parseFloat(parts[2]) || 0;
        // W coordinate (parts[3]) is optional and ignored for Vector2
        objUVs.push({ u, v });
        break;

      case 'vn': // Vertex normal
        const nx = parseFloat(parts[1]) || 0;
        const ny = parseFloat(parts[2]) || 0;
        const nz = parseFloat(parts[3]) || 0;
        objNormals.push({ x: nx, y: ny, z: nz });
        break;

      case 'f': // Face
        const faceVertexData = parts.slice(1);
        const meshVertexIdsForFace: ID[] = [];
        const faceUVs: Vector2[] = [];
        let hasUVs = false;

        for (const vertexStr of faceVertexData) {
          const vertexIndices = vertexStr.split('/');
          const vIndex = parseInt(vertexIndices[0], 10);
          
          // OBJ indices are 1-based, convert to 0-based for array access if needed,
          // but here we use it to get the pre-stored mesh ID.
          const currentMeshVertexId = objVertexIndexToMeshId[vIndex - 1];
          if (currentMeshVertexId === undefined) {
            console.warn(`Invalid vertex index ${vIndex} in face definition: ${trimmedLine}`);
            continue;
          }
          meshVertexIdsForFace.push(currentMeshVertexId);

          if (vertexIndices.length > 1 && vertexIndices[1] !== '') {
            const vtIndex = parseInt(vertexIndices[1], 10);
            const uv = objUVs[vtIndex - 1]; // 1-based to 0-based
            if (uv) {
              faceUVs.push(uv);
              hasUVs = true;
            } else {
              console.warn(`Invalid UV index ${vtIndex} in face definition: ${trimmedLine}`);
              // Add a default UV if one is missing to maintain array length consistency
              faceUVs.push({ u: 0, v: 0 }); 
            }
          }
          // Vertex normal index (vertexIndices[2]) is parsed but not directly used yet
          // as EditableMesh calculates normals or uses the Three.js adapter's capabilities.
        }

        if (meshVertexIdsForFace.length >= 3) {
          const faceId = mesh.addFace(meshVertexIdsForFace);
          if (hasUVs && faceUVs.length === meshVertexIdsForFace.length) {
            mesh.updateFaceUVs(faceId, faceUVs);
          }
        } else {
          console.warn(`Face with less than 3 vertices skipped: ${trimmedLine}`);
        }
        break;
    }
  }
  return mesh;
}

/**
 * Exports an EditableMesh instance to an OBJ file format string.
 * 
 * @param mesh The EditableMesh to export.
 * @returns A string representing the mesh in OBJ format.
 */
export function exportOBJ(mesh: EditableMesh): string {
  let objContent = '# OBJ file generated by @your-org/mesh-editor\n';
  objContent += '# https://github.com/your-org/mesh-editor\n\n';

  const vertices = Array.from(mesh.getVertices());
  const faces = Array.from(mesh.getFaces());

  // --- Vertices (v) ---
  const vertexIdToObjIndex = new Map<ID, number>();
  objContent += '# Vertices\n';
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    objContent += `v ${vertex.position.x} ${vertex.position.y} ${vertex.position.z}\n`;
    vertexIdToObjIndex.set(vertex.id, i + 1); // 1-based index
  }
  objContent += `\n`;

  // --- Texture Coordinates (vt) ---
  // Collect all unique UVs from all faces to write a global vt list
  const uniqueUVs: Vector2[] = [];
  const uvToStringMap = new Map<string, number>(); // Maps "u,v" to 1-based index in uniqueUVs

  objContent += '# Texture Coordinates\n';
  for (const face of faces) {
    for (const uv of face.uvs) {
      const uvKey = `${uv.u},${uv.v}`;
      if (!uvToStringMap.has(uvKey)) {
        uniqueUVs.push(uv);
        uvToStringMap.set(uvKey, uniqueUVs.length); // 1-based index
      }
    }
  }

  for (const uv of uniqueUVs) {
    objContent += `vt ${uv.u} ${uv.v}\n`;
  }
  objContent += `\n`;
  
  // --- Vertex Normals (vn) --- 
  // Not implemented in this version, as EditableMesh computes them on demand
  // or relies on the rendering adapter. OBJ typically expects them if referenced in faces.
  objContent += '# Vertex Normals (not exported in this version)\n\n';

  // --- Faces (f) ---
  objContent += '# Faces\n';
  for (const face of faces) {
    let faceLine = 'f';
    for (let i = 0; i < face.vertexIds.length; i++) {
      const vertexId = face.vertexIds[i];
      const objVertexIndex = vertexIdToObjIndex.get(vertexId);

      if (objVertexIndex === undefined) {
        console.warn(`Cannot find OBJ index for vertex ID ${vertexId} in face ${face.id}. Skipping vertex in face.`);
        continue;
      }

      faceLine += ` ${objVertexIndex}`;

      // Get the UV for this specific vertex in this face's context
      if (face.uvs && face.uvs.length === face.vertexIds.length) {
        const currentUV = face.uvs[i];
        const uvKey = `${currentUV.u},${currentUV.v}`;
        const objUVIndex = uvToStringMap.get(uvKey);
        if (objUVIndex !== undefined) {
          faceLine += `/${objUVIndex}`;
        }
        // If normals were exported, the format would be v/vt/vn or v//vn
        // Since normals are not exported, we only add /vt if vt exists.
      } else {
        // If no UVs or mismatched count, just use vertex index (e.g. "f v1 v2 v3")
        // Or could use "f v1// v2// v3//" if we wanted to signify no UVs but space for normals
      }
    }
    objContent += `${faceLine}\n`;
  }

  return objContent;
}
